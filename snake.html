<!DOCTYPE html>
<html>

<body>
    <canvas id="myCanvas" width="600" height="600" style="border:1px solid #c3c3c3;">
        Your browser does not support the canvas element.
    </canvas>

    <input onkeypress="stopRun()">

    <script>
        ////////////开篇名义:
        ////////////1.色块颜色代号：0―路-白色;    1―头-黑色;    2―身体、尾巴-红色;    3―路障-绿色;

        function roadblockCreate()//随机生成若干个路障
        {
            var 路障序号 = new Array();

            //随机选取，检查是否已经有这个选择的数，如果没有，则加入备选。
            for (var i = 0; i < 路障个数; i++) {
                var a = 0;
                while (a < 1000000) {
                    var 选择 = Math.floor(Math.random() * num * num - 0.001);
                    if (路障序号.indexOf(选择) == -1) //Array.indexOf(number):查找数组中是否有该值。如果不返回-1而返回相应序号，则说明被找到了；返回-1，说明没有找到。
                    {

                        路障序号[i] = 选择;
                        break;
                    }
                }
            }
            //根据路障，生成地形
            var counterearth = 0;//用于记录地块的序号
            //检测每个地块的序号，是否在路障序号里，如果有，则生成障碍物。
            for (var 行数 = 0; 行数 < num; 行数++) {
                地形矩阵[行数] = new Array();
                for (var 列数 = 0; 列数 < num; 列数++) {
                    if (路障序号.indexOf(counterearth) != -1)//检测每个地块的序号，是否在路障序号里
                    {
                        地形矩阵[行数][列数] = 3;
                    }
                    else 地形矩阵[行数][列数] = 0;

                    counterearth++;
                }
            }


        }

        //可停止定时器
        function stopRun() {
            clearInterval(id);
        }



        //移动规则：通过检查上次一格子是否为白色（是否为0）来决定移动是否能朝该方向移动。比2.0的移动规则算法更加普世与通过一些。
        //还是有一些缺陷。缺陷1：如果数组的“行”没有被定义，则会出错。需要加入其他判定条件:先判定数组(特别是“行”)是否被定义，再来判断是否有“路”。
        //缺陷2：还不能预测下下步是否为死路...话说，这个缺陷确实苛刻了点，需要加其他判定条件。
        function 移动规则(生物当前位置_行, 生物当前位置_列) {
            //1.先制作备选框、备选序号
            var box = new Array();
            var boxNum = 0;

            //2.开始判断方向，符合的方向将入选。入选条件：1.不能撞墙；
            if (typeof (当前世界矩阵[生物当前位置_行 + 1]) != "undefined" && 当前世界矩阵[生物当前位置_行 + 1][生物当前位置_列] == 0) //如果[下]方有“路”，则可移动。
            {
                box[boxNum] = "down";
                boxNum++;

            }

            if (typeof (当前世界矩阵[生物当前位置_行 - 1]) != "undefined" && 当前世界矩阵[生物当前位置_行 - 1][生物当前位置_列] == 0)////如果[上]方有“路”，则可移动。
            {
                box[boxNum] = "up";
                boxNum++;
            }

            if (当前世界矩阵[生物当前位置_行][生物当前位置_列 - 1] != null && 当前世界矩阵[生物当前位置_行][生物当前位置_列 - 1] == 0)////如果[左]方有“路”，则可移动。
            {
                box[boxNum] = "left";
                boxNum++;
            }

            if (当前世界矩阵[生物当前位置_行][生物当前位置_列 + 1] != null && 当前世界矩阵[生物当前位置_行][生物当前位置_列 + 1] == 0)////如果[右]方有“路”，则可移动。
            {
                box[boxNum] = "right"
                boxNum++;//这一行还是要保留，为方便之后向下舍入
            }

            //3.入选后，开始随机选择
            /*走投无路时，则游戏结束
            if (box.length == 0)
            {
                alert("游戏结束");
                stopRun();
            }
            */
            if (Math.random() * boxNum == 4) var sel = box[Math.floor(Math.random() * boxNum - 0.01)];//如果不小心等于4，则人为减小一点，以方便舍入。
            else var sel = box[Math.floor(Math.random() * boxNum)];

            //console.log(box);
            //console.log(sel);

            //4.开始判断方向，
            if (sel == "up") {
                当前世界矩阵[生物当前位置_行 - 1][生物当前位置_列] = 1;

                上帝的快递员_行 = 生物当前位置_行 - 1;
                上帝的快递员_列 = 生物当前位置_列;
            }

            else if (sel == "down") {
                当前世界矩阵[生物当前位置_行 + 1][生物当前位置_列] = 1;

                上帝的快递员_行 = 生物当前位置_行 + 1;
                上帝的快递员_列 = 生物当前位置_列;
            }

            else if (sel == "left") {
                当前世界矩阵[生物当前位置_行][生物当前位置_列 - 1] = 1;

                上帝的快递员_行 = 生物当前位置_行;
                上帝的快递员_列 = 生物当前位置_列 - 1;
            }

            else if (sel == "right") {
                当前世界矩阵[生物当前位置_行][生物当前位置_列 + 1] = 1;

                上帝的快递员_行 = 生物当前位置_行;
                上帝的快递员_列 = 生物当前位置_列 + 1;
            }

            else {
                当前世界矩阵[生物当前位置_行][生物当前位置_列] = 1;

                上帝的快递员_行 = 生物当前位置_行;
                上帝的快递员_列 = 生物当前位置_列;
            }



        }

        //1.生成世界，并生成生物。
        function initial() {
            //1.1 在方格中随机生成若干个生物的

            var 生物序号 = new Array();

            var numCounter = 0;//计数器

            //随机选取，检查是否已经有这个选择的数，如果没有，则加入备选。
            for (var i = 0; i < 生物数量; i++) {
                var a = 0;
                while (a < 1000000) {
                    var 选择 = Math.floor(Math.random() * num * num - 0.001);
                    if (生物序号.indexOf(选择) == -1) //Array.indexOf(number):查找数组中是否有该值。如果不返回-1而返回相应序号，则说明被找到了；返回-1，说明没有找到。
                    {

                        生物序号.push(选择);//将参数添加至数组的末尾
                        break;
                    }
                }
            }

            //1.2 创建世界
            //1.2.1 创建地形
            roadblockCreate();
            //1.2.2 将地形数据传到当前世界中
            for (var 行数 = 0; 行数 < num; 行数++) {
                当前世界矩阵[行数] = new Array();
                for (var 列数 = 0; 列数 < num; 列数++) {
                    当前世界矩阵[行数][列数] = 地形矩阵[行数][列数];
                }
            }


            //1.3 将生物数据传入当前世界中
            var sw = 0;
            for (var 行数 = 0; 行数 < num; 行数++) {
                for (var 列数 = 0; 列数 < num; 列数++) {
                    if (生物序号.indexOf(numCounter) != -1) {
                        当前世界矩阵[行数][列数] = 1;
                        生物们[sw].头_记录行数 = 行数;
                        生物们[sw].头_记录列数 = 列数;
                        sw++;
                    }
                    if (sw < 生物数量) numCounter++;
                    else break;
                }
                if (sw == 生物数量) break;
            }


            //1.4 逐行打印变量
            for (var 行数 = 0; 行数 < num; 行数++) {
                for (var 列数 = 0; 列数 < num; 列数++) {


                    if (当前世界矩阵[行数][列数] == 0) //打印路
                    {
                        ctx.fillStyle = "#FFFFFF";
                    }
                    else if (当前世界矩阵[行数][列数] == 1) //打印“头”
                    {
                        ctx.fillStyle = "#000000";
                    }
                    else if (当前世界矩阵[行数][列数] == 2) //打印“身体”
                    {
                        ctx.fillStyle = "#FF3030";
                    }
                    else if (当前世界矩阵[行数][列数] == 3)//打印“路障”
                    {
                        ctx.fillStyle = "#00EE00";
                    }
                    ctx.fillRect(列数 * 方格尺寸, 行数 * 方格尺寸, 方格尺寸, 方格尺寸);//这里注意：X坐标对应的其实是[列数]，y坐标对应的是[行数]！！！！！！！！！！！！！！！！！！
                    //ctx.rect(行数 * 方格尺寸, 列数 * 方格尺寸, 方格尺寸, 方格尺寸);
                }
            }

        }

        //2. 开始迭代
        function update() {
            //2.1 再次将生物1数据传入世界中
            var sw = 0;
            for (var 行数 = 0; 行数 < num; 行数++) {
                if (sw < 生物数量) {
                    for (var 列数 = 0; 列数 < num; 列数++) {

                        if (行数 == 生物们[sw].头_记录行数 && 列数 == 生物们[sw].头_记录列数) //找到“头”当前所在位置
                        {

                            //头移动
                            移动规则(行数, 列数);

                            //过去久远的痕迹，就随风消逝了。
                            if (生物们[sw].尾2_记录行数 != null && 生物们[sw].尾2_记录列数 != null) {
                                当前世界矩阵[生物们[sw].身_记录行数][生物们[sw].身_记录列数] = 0;
                                当前世界矩阵[生物们[sw].尾_记录行数][生物们[sw].尾_记录列数] = 0;
                                当前世界矩阵[生物们[sw].尾2_记录行数][生物们[sw].尾2_记录列数] = 0;
                            }


                            //将“尾”的位置传给“阑尾”。233333333~~~~
                            生物们[sw].尾2_记录行数 = 生物们[sw].尾_记录行数;
                            生物们[sw].尾2_记录列数 = 生物们[sw].尾_记录列数;

                            //将“身”的位置传给“尾”。
                            生物们[sw].尾_记录行数 = 生物们[sw].身_记录行数;
                            生物们[sw].尾_记录列数 = 生物们[sw].身_记录列数;

                            //将“头”的位置传给“身”。
                            生物们[sw].身_记录行数 = 生物们[sw].头_记录行数;
                            生物们[sw].身_记录列数 = 生物们[sw].头_记录列数;

                            //将函数中，新的位置，通过全局参数传递出来。
                            生物们[sw].头_记录行数 = 上帝的快递员_行;
                            生物们[sw].头_记录列数 = 上帝的快递员_列;

                            上帝的快递员_行 = null;//清洗干净下次再用
                            上帝的快递员_列 = null;//清洗干净下次再用

                            //尾跟随
                            当前世界矩阵[生物们[sw].身_记录行数][生物们[sw].身_记录列数] = 2;
                            当前世界矩阵[生物们[sw].尾_记录行数][生物们[sw].尾_记录列数] = 2;
                            当前世界矩阵[生物们[sw].尾2_记录行数][生物们[sw].尾2_记录列数] = 2;

                            sw++;
                            行数 = 0;
                            列数 = 0;
                            if (sw == 生物数量) break;
                        }

                    }
                }
                else break;

            }


            //2.3 逐行打印变量
            for (var 行数 = 0; 行数 < num; 行数++) {
                for (var 列数 = 0; 列数 < num; 列数++) {

                    if (当前世界矩阵[行数][列数] == 0) {
                        ctx.fillStyle = "#FFFFFF";
                    }
                    else if (当前世界矩阵[行数][列数] == 1) {
                        ctx.fillStyle = "#000000";
                    }
                    else if (当前世界矩阵[行数][列数] == 2) {
                        ctx.fillStyle = "#FF3030";
                    }
                    else if (当前世界矩阵[行数][列数] == 3) {
                        ctx.fillStyle = "#00EE00";
                    }
                    ctx.fillRect(列数 * 方格尺寸, 行数 * 方格尺寸, 方格尺寸, 方格尺寸);//这里注意：X坐标对应的其实是[列数]，y坐标对应的是[行数]！！！！！！！！！！！！！！！！！！
                    //ctx.rect(行数 * 方格尺寸, 列数 * 方格尺寸, 方格尺寸, 方格尺寸);
                }
            }

        }



        //创造宇宙
        var canvas = document.getElementById("myCanvas");
        canvas.width = 600;
        canvas.height = 600;
        var num = 50;
        方格尺寸 = canvas.width / num;
        var ctx = canvas.getContext("2d");

        //创造世界
        var 当前世界矩阵 = new Array();//包括、地形、生物。加入这个矩阵，主要是为了让生物矩阵隶属于他，而不再让生物矩阵成为世界的中心。这样，就可以放更多的生物了~
        var 上帝的快递员_行;//函数内的值，不能返回多个，所以就用快递小哥来帮忙把函数内的多个结果“运送”出来给函数外的参数。
        var 上帝的快递员_列;//函数内的值，不能返回多个，所以就用快递小哥来帮忙把函数内的多个结果“运送”出来给函数外的参数。
        //创造地形
        var 路障个数 = 500;
        var 地形矩阵 = new Array();


        //创造生物
        function 生物()//！！！！！！！！！！！！javascript中创建类的方法！！！很重要
        {
            this.头_记录行数 = 0;
            this.头_记录列数 = 0;
            this.身_记录行数 = null;
            this.身_记录列数 = null;
            this.尾_记录行数 = null;
            this.尾_记录列数 = null;
            this.尾2_记录行数 = null;
            this.尾2_记录列数 = null;
        }
        //生物们[sw]
        var 生物1 = new 生物();
        //生物2
        var 生物2 = new 生物();
        
        //生物3
        var 生物3=new 生物();
        //生物4
        var 生物4=new 生物();
        //生物5
        var 生物5=new 生物();
        //生物6
        var 生物6=new 生物();
        //生物7
        var 生物7 = new 生物();
        var 生物8 = new 生物();
        var 生物9 = new 生物();
        var 生物10 = new 生物();
        var 生物11 = new 生物();
        var 生物12 = new 生物();
        var 生物13 = new 生物();
        var 生物14 = new 生物();
        var 生物15 = new 生物();
        var 生物16 = new 生物();
        var 生物17 = new 生物();
        var 生物18 = new 生物();
        var 生物19 = new 生物();
        var 生物20 = new 生物();
        

        //打个包
        var 生物们 = new Array(生物1, 生物2, 生物3, 生物4, 生物5, 生物6, 生物7, 生物8, 生物9, 生物10, 生物11, 生物12, 生物13, 生物14, 生物15, 生物16, 生物17, 生物18, 生物19, 生物20);
        //var 生物们 = new Array(生物1, 生物2);
        var 生物数量 = 生物们.length;//生物的数量



        //世界开始第一次运行
        initial();
        //世界开始不停地运行
        var id = setInterval(update, 100);//定时器，每多少秒执行一次。

        //clearInterval(id);//可停止定时器

    </script>

</body>

</html>