<!DOCTYPE html>
<html>

<body>
    <canvas id="myCanvas" width="600" height="600" style="border:1px solid #c3c3c3;">
        Your browser does not support the canvas element.
    </canvas>

    <input onkeypress="stopRun()">

    <script>
        ////////////开篇名义:
        ////////////1.色块颜色代号：0―路-白色;    1―头-黑色;    2―身体、尾巴-红色;    3―路障-绿色;    



        function roadblockCreate()//随机生成若干个路障
        {
            var 路障个数 = 400;
            var 路障序号 = new Array();

            //随机选取，检查是否已经有这个选择的数，如果没有，则加入备选。
            for (var i = 0; i < 路障个数; i++)
            {
                var a = 0;
                while (a < 1000000)
                {
                    var 选择 = Math.floor(Math.random() * num * num - 0.001);
                    if (路障序号.indexOf(选择) == -1) //Array.indexOf(number):查找数组中是否有该值。如果不返回-1而返回相应序号，则说明被找到了；返回-1，说明没有找到。
                    {

                        路障序号[i] = 选择;
                        break;
                    }
                }    
            }
            //根据路障，生成地形
            var counterearth = 0;//用于记录地块的序号
            //检测每个地块的序号，是否在路障序号里，如果有，则生成障碍物。
            for (var 行数 = 0; 行数 < num; 行数++) {
                地形矩阵[行数] = new Array();
                for (var 列数 = 0; 列数 < num; 列数++)
                {
                    if (路障序号.indexOf(counterearth) != -1)//检测每个地块的序号，是否在路障序号里
                    {
                        地形矩阵[行数][列数] = 3;
                    }
                    else 地形矩阵[行数][列数] = 0;

                    counterearth++;
                }
            }


        }




        //可停止定时器
        function stopRun() {
            clearInterval(id);
        }





        //移动规则：通过检查上次一格子是否为白色（是否为0）来决定移动是否能朝该方向移动。比2.0的移动规则算法更加普世与通过一些。
        //还是有一些缺陷。缺陷1：如果数组的“行”没有被定义，则会出错。需要加入其他判定条件:先判定数组(特别是“行”)是否被定义，再来判断是否有“路”。
        //缺陷2：还不能预测下下步是否为死路...话说，这个缺陷确实苛刻了点，需要加其他判定条件。
        function 移动规则(行数, 列数, 生物1行动痕迹) {
            //1.先制作备选框、备选序号
            var box = new Array();
            var boxNum = 0;

            //2.开始判断方向，符合的方向将入选。入选条件：1.不能撞墙；
            if (typeof (生物1行动痕迹[行数 + 1]) != "undefined" && 生物1行动痕迹[行数 + 1][列数] == 0) //如果[下]方有“路”，则可移动。
            {
                box[boxNum] = "down";
                boxNum++;
            }

            if (typeof (生物1行动痕迹[行数 - 1]) != "undefined" && 生物1行动痕迹[行数 - 1][列数] == 0)////如果[上]方有“路”，则可移动。
            {
                box[boxNum] = "up";
                boxNum++;
            }

            if (生物1行动痕迹[行数][列数 - 1] != null && 生物1行动痕迹[行数][列数 - 1] == 0)////如果[左]方有“路”，则可移动。
            {
                box[boxNum] = "left";
                boxNum++;
            }

            if (生物1行动痕迹[行数][列数 + 1] != null && 生物1行动痕迹[行数][列数 + 1] == 0)////如果[右]方有“路”，则可移动。
            {
                box[boxNum] = "right"
                boxNum++;//这一行还是要保留，为方便之后向下舍入
            }

            //3.入选后，开始随机选择 
            /*走投无路时，则游戏结束
            if (box.length == 0)
            {
                alert("游戏结束");
                stopRun();
            }
            */
            if (Math.random() * boxNum == 4) var sel = box[Math.floor(Math.random() * boxNum - 0.01)];//如果不小心等于4，则人为减小一点，以方便舍入。
            else var sel = box[Math.floor(Math.random() * boxNum)];

            console.log(box);
            console.log(sel);

            //4.开始判断方向，
            if (sel == "up") {
                生物1[行数 - 1][列数] = 1;

                头_记录行数 = 行数 - 1;
                头_记录列数 = 列数;
            }

            else if (sel == "down") {
                生物1[行数 + 1][列数] = 1;

                头_记录行数 = 行数 + 1;
                头_记录列数 = 列数;
            }

            else if (sel == "left") {
                生物1[行数][列数 - 1] = 1;

                头_记录行数 = 行数;
                头_记录列数 = 列数 - 1;
            }

            else if (sel == "right") {
                生物1[行数][列数 + 1] = 1;

                头_记录行数 = 行数;
                头_记录列数 = 列数 + 1;
            }

            else {
                生物1[行数][列数] = 1;

                头_记录行数 = 行数;
                头_记录列数 = 列数;
            }



        }

        //1. 在网格中随机生成一个有头的物体
        function initial() {
            //1.1 在方格中随机生成一个物体的
            var allMem = num * num;//获取成员总量
            var pointMem = Math.round(Math.random() * (allMem - 1));//获取需要变为物体的格子的序号
            var numCounter = 0;//计数器

            //1.2 生成地形
            roadblockCreate();

            //1.3 开始生成网格，检测是否为物体：为物体时，网格标记为1，其余都标记为0。
            for (var 行数 = 0; 行数 < num; 行数++) {
                生物1[行数] = new Array();
                for (var 列数 = 0; 列数 < num; 列数++) {
                    if (pointMem == numCounter) {
                        生物1[行数][列数] = 1;
                        console.log("行数1：   " + 行数);
                        console.log("列数1：   " + 列数);
                        头_记录行数 = 行数;
                        头_记录列数 = 列数;

                        身_记录行数 = 行数;
                        身_记录列数 = 列数;
                    }
                    else
                    {
                        生物1[行数][列数] = 地形矩阵[行数][列数];
                    }

                    numCounter++;
                }
            }


            //1.4 将该次的生物1状态记录在“生物1行动痕迹中”
            for (var 行数 = 0; 行数 < num; 行数++) {
                生物1行动痕迹[行数] = new Array();
                for (var 列数 = 0; 列数 < num; 列数++) {
                    生物1行动痕迹[行数][列数] = 生物1[行数][列数];
                }
            }

            //1.5 逐行打印变量
            for (var 行数 = 0; 行数 < num; 行数++) {
                for (var 列数 = 0; 列数 < num; 列数++) {

                    if (生物1[行数][列数] == 0) {
                        ctx.fillStyle = "#FFFFFF";
                    }
                    else if (生物1[行数][列数] == 1) {
                        ctx.fillStyle = "#000000";
                    }
                    else if (生物1[行数][列数] == 2) {
                        ctx.fillStyle = "#FF3030";
                    }
                    else if (生物1[行数][列数] == 3) {
                        ctx.fillStyle = "#00EE00";
                    }
                    ctx.fillRect(列数 * 方格尺寸, 行数 * 方格尺寸, 方格尺寸, 方格尺寸);//这里注意：X坐标对应的其实是[列数]，y坐标对应的是[行数]！！！！！！！！！！！！！！！！！！
                    //ctx.rect(行数 * 方格尺寸, 列数 * 方格尺寸, 方格尺寸, 方格尺寸);
                }
            }

        }

        //2. 开始迭代
        function update() {
            //2.1 开始将所有格子变为0,重新生成地形
            for (var 行数 = 0; 行数 < num; 行数++) {
                for (var 列数 = 0; 列数 < num; 列数++) {
                    生物1[行数][列数] = 地形矩阵[行数][列数];
                }
            }

            //2.2 将物体头改为1，尾改为2
            var 检测 = 0;
            for (var 行数 = 0; 行数 < num; 行数++) {
                if (检测 == 0) {
                    for (var 列数 = 0; 列数 < num; 列数++) {
                        if (行数 == 头_记录行数 && 列数 == 头_记录列数) {//找到“头”当前所在位置

                            //头移动
                            移动规则(行数, 列数, 生物1行动痕迹);

                            //尾6_记录行数 = 尾5_记录行数;
                            //尾6_记录列数 = 尾5_记录列数;

                            //尾5_记录行数 = 尾4_记录行数;
                            //尾5_记录列数 = 尾4_记录列数;

                            //尾4_记录行数 = 尾3_记录行数;
                            //尾4_记录列数 = 尾3_记录列数;

                            //尾3_记录行数 = 尾2_记录行数;
                            //尾3_记录列数 = 尾2_记录列数;

                            尾2_记录行数 = 尾_记录行数;
                            尾2_记录列数 = 尾_记录列数;

                            尾_记录行数 = 身_记录行数;
                            尾_记录列数 = 身_记录列数;

                            //将“头”的位置传给“尾”。
                            身_记录行数 = 行数;
                            身_记录列数 = 列数;

                            //尾跟随
                            生物1[身_记录行数][身_记录列数] = 2;
                            生物1[尾_记录行数][尾_记录列数] = 2;
                            生物1[尾2_记录行数][尾2_记录列数] = 2;
                            //生物1[尾3_记录行数][尾3_记录列数] = 2;
                            //生物1[尾4_记录行数][尾4_记录列数] = 2;
                            //生物1[尾5_记录行数][尾5_记录列数] = 2;
                            //生物1[尾6_记录行数][尾6_记录列数] = 2;

                            检测 = 1;
                            break;
                        }

                    }
                }
                else break;

            }

            //2.3 将该次的生物1状态记录在“生物1行动痕迹中”
            for (var 行数 = 0; 行数 < num; 行数++) {
                for (var 列数 = 0; 列数 < num; 列数++) {
                    生物1行动痕迹[行数][列数] = 生物1[行数][列数];
                }
            }


            //2.4 逐行打印变量
            for (var 行数 = 0; 行数 < num; 行数++) {
                for (var 列数 = 0; 列数 < num; 列数++) {

                    if (生物1[行数][列数] == 0) {
                        ctx.fillStyle = "#FFFFFF";
                    }
                    else if (生物1[行数][列数] == 1) {
                        ctx.fillStyle = "#000000";
                    }
                    else if (生物1[行数][列数] == 2) {
                        ctx.fillStyle = "#FF3030";
                    }
                    else if (生物1[行数][列数] == 3) {
                        ctx.fillStyle = "#00EE00";
                    }
                    ctx.fillRect(列数 * 方格尺寸, 行数 * 方格尺寸, 方格尺寸, 方格尺寸);//这里注意：X坐标对应的其实是[列数]，y坐标对应的是[行数]！！！！！！！！！！！！！！！！！！
                    //ctx.rect(行数 * 方格尺寸, 列数 * 方格尺寸, 方格尺寸, 方格尺寸);
                }
            }

        }


        var 地形矩阵 = new Array();
        var 生物1 = new Array();
        var 生物1行动痕迹 = new Array();

        var canvas = document.getElementById("myCanvas");

        canvas.width = 600;
        canvas.height = 600;
        var num = 50;

        方格尺寸 = canvas.width / num;
        var ctx = canvas.getContext("2d");

        var 头_记录行数 = 0;
        var 头_记录列数 = 0;
        var 身_记录行数 = 0;
        var 身_记录列数 = 0;
        var 尾_记录行数 = null;
        var 尾_记录列数 = null;
        var 尾2_记录行数 = null;
        var 尾2_记录列数 = null;
        //var 尾3_记录行数 = null;
        //var 尾3_记录列数 = null;
        //var 尾4_记录行数 = null;
        //var 尾4_记录列数 = null;
        //var 尾5_记录行数 = null;
        //var 尾5_记录列数 = null;
        //var 尾6_记录行数 = null;
        //var 尾6_记录列数 = null;


        initial();

        var id = setInterval(update, 50);//定时器，每多少秒执行一次。

        //clearInterval(id);//可停止定时器

    </script>

</body>

</html>